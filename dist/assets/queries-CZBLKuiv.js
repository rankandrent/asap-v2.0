import{h as d,s as b}from"./index-BaYg4v0E.js";const C={Amatom:[{name:"Standoffs",slug:"standoffs",subcategoryCount:6},{name:"Handles",slug:"handles",subcategoryCount:2},{name:"Spacers",slug:"spacers",subcategoryCount:7},{name:"Screws And Bolts",slug:"screws-and-bolts",subcategoryCount:2},{name:"Washers",slug:"washers",subcategoryCount:1},{name:"Bearings And Bushings",slug:"bearings-and-bushings",subcategoryCount:1}]},h={Amatom:{standoffs:[{name:"Brass Standoffs",slug:"brass-standoffs",partCount:122484},{name:"Aluminum Standoffs",slug:"aluminum-standoffs",partCount:120406},{name:"Steel Standoffs",slug:"steel-standoffs",partCount:82461},{name:"Stainless Steel Standoffs",slug:"stainless-steel-standoffs",partCount:35868},{name:"Phenolic Standoffs",slug:"phenolic-standoffs",partCount:6616},{name:"Nylon Standoffs",slug:"nylon-standoffs",partCount:4645}],handles:[{name:"Surface Mount Handles",slug:"surface-mount-handles",partCount:66634},{name:"Handle Ferrules",slug:"handle-ferrules",partCount:633}],spacers:[{name:"Aluminum Spacers",slug:"aluminum-spacers",partCount:14950},{name:"Brass Spacers",slug:"brass-spacers",partCount:14888},{name:"Steel Spacers",slug:"steel-spacers",partCount:8502},{name:"Stainless Steel Spacers",slug:"stainless-steel-spacers",partCount:4472},{name:"Phenolic Spacers",slug:"phenolic-spacers",partCount:2105},{name:"Nylon Spacers",slug:"nylon-spacers",partCount:1498},{name:"Cpvc Spacers",slug:"cpvc-spacers",partCount:12}],"screws-and-bolts":[{name:"Captive Screws",slug:"captive-screws",partCount:13613},{name:"Jack Screws",slug:"jack-screws",partCount:24}],washers:[{name:"Captive Screw Washers",slug:"captive-screw-washers",partCount:160}],"bearings-and-bushings":[{name:"Bushings",slug:"bushings",partCount:29}]}},k=async o=>{if(!o||o.trim()==="")return console.error("âŒ getCategories: No manufacturer provided"),[];console.log(`ðŸ”„ getCategories: Starting for manufacturer: ${o}`);const c=Date.now();if(o==="Amatom"&&C[o])return console.log("âœ… getCategories: Using HARDCODED fallback for",o),C[o];try{console.log("ðŸ” getCategories: Trying RPC function...");const t=d.rpc("get_categories_summary",{p_manufacturer_name:o}).then(l=>l),e=new Promise(l=>{setTimeout(()=>{l({data:null,error:{message:"RPC timeout",code:"TIMEOUT"}})},5e3)}),a=await Promise.race([t,e]).catch(l=>(console.warn("âš ï¸ getCategories: RPC function timeout or error:",l),{data:null,error:{message:"RPC timeout",code:"TIMEOUT"}})),s=a.data,n=a.error;if(n)n.code==="42883"||n.message?.includes("function")||n.message?.includes("does not exist")?console.warn("âš ï¸ getCategories: RPC function does not exist, using fallback method"):console.warn("âš ï¸ getCategories: RPC function error:",n);else if(s&&s.length>0){console.log("âœ… getCategories: RPC function succeeded!",s.length,"categories");const l=s.map(u=>({name:u.category_name,slug:b(u.category_name),subcategoryCount:Number(u.subcategory_count)})).sort((u,i)=>u.name==="Standoffs"&&i.name!=="Standoffs"?-1:i.name==="Standoffs"&&u.name!=="Standoffs"?1:u.name.localeCompare(i.name));return console.log(`âœ… getCategories: Completed in ${Date.now()-c}ms`),l}else console.warn("âš ï¸ getCategories: RPC function returned no data, using fallback")}catch(t){console.warn("âš ï¸ getCategories: RPC function exception, using fallback:",t)}console.log("ðŸ”„ getCategories: Using fallback method with smart sampling...");const r=new Map;try{console.log("ðŸ“‹ getCategories: Step 1 - Getting unique categories...");const t=d.from("products_data").select("category").eq("manufacturer",o).not("category","is",null).neq("category","").limit(1e4).then(n=>n),e=new Promise(n=>{setTimeout(()=>{n({data:null,error:new Error("Query timeout")})},8e3)}),a=await Promise.race([t,e]).catch(n=>(console.error("Query timeout:",n),{data:null,error:n}));if(a.error)throw console.error("âŒ getCategories: Error fetching categories:",a.error),a.error;if(!a.data||a.data.length===0)return console.warn("âš ï¸ getCategories: No categories found"),[];const s=new Set;a.data.forEach(n=>{n.category?.trim()&&s.add(n.category.trim())}),console.log(`âœ… getCategories: Found ${s.size} unique categories:`,Array.from(s)),console.log("ðŸ“‹ getCategories: Step 2 - Getting subcategories for each category...");for(const n of s){const l=d.from("products_data").select("sub_category").eq("manufacturer",o).eq("category",n).not("sub_category","is",null).neq("sub_category","").limit(1e3).then(m=>m),u=new Promise(m=>{setTimeout(()=>{m({data:null,error:new Error("Query timeout")})},5e3)}),i=await Promise.race([l,u]).catch(m=>(console.warn(`âš ï¸ getCategories: Timeout for category ${n}:`,m),{data:null,error:m}));if(i.error){console.warn(`âš ï¸ getCategories: Error fetching subcategories for ${n}:`,i.error),r.set(n,new Set);continue}if(i.data&&i.data.length>0){const m=new Set;i.data.forEach(S=>{S.sub_category?.trim()&&m.add(S.sub_category.trim())}),r.set(n,m),console.log(`  âœ… ${n}: ${m.size} subcategories`)}else r.set(n,new Set),console.log(`  âš ï¸ ${n}: No subcategories found`)}console.log(`âœ… getCategories: Processed ${r.size} categories`)}catch(t){return console.error("âŒ getCategories: Error in fallback method:",t),[]}const g=Array.from(r.entries()).map(([t,e])=>({name:t,slug:b(t),subcategoryCount:e.size})).sort((t,e)=>t.name==="Standoffs"&&e.name!=="Standoffs"?-1:e.name==="Standoffs"&&t.name!=="Standoffs"?1:t.name.localeCompare(e.name));return console.log(`âœ… getCategories: Completed in ${Date.now()-c}ms, returning ${g.length} categories`),g},P=async(o,c)=>{if(!c||c.trim()==="")return console.error("âŒ getCategoryNameFromSlug: No manufacturer provided"),null;if(!o||o.trim()==="")return console.error("âŒ getCategoryNameFromSlug: No category slug provided"),null;console.log(`ðŸ” getCategoryNameFromSlug: Looking for category slug: ${o}, manufacturer: ${c}`);const{data:r,error:g}=await d.from("products_data").select("category").eq("manufacturer",c).not("category","is",null).neq("category","").limit(1e3);if(g)throw console.error("âŒ getCategoryNameFromSlug: Query error:",g),g;if(!r||r.length===0)return console.warn(`âš ï¸ getCategoryNameFromSlug: No data found for manufacturer: ${c}`),null;const t=new Set;r.forEach(e=>{e.category&&e.category.trim()!==""&&t.add(e.category.trim())}),console.log(`ðŸ“¦ getCategoryNameFromSlug: Found ${t.size} unique categories:`,Array.from(t));for(const e of t)if(b(e)===o)return console.log(`âœ… getCategoryNameFromSlug: Found match! ${e} -> ${o}`),e;return console.warn(`âš ï¸ getCategoryNameFromSlug: No category found for slug: ${o}`),console.warn("Available categories:",Array.from(t).map(e=>`${e} -> ${b(e)}`)),null},A=async(o,c)=>{if(!c||c.trim()==="")return console.error("âŒ getSubcategories: No manufacturer provided"),[];if(!o||o.trim()==="")return console.error("âŒ getSubcategories: No category slug provided"),[];if(console.log(`ðŸ”„ getSubcategories: Starting for category: ${o}, manufacturer: ${c}`),c==="Amatom"&&h[c]?.[o]){console.log("âœ… getSubcategories: Using HARDCODED fallback for",c,o);const a=C[c]?.find(s=>s.slug===o)?.name||o.replace(/-/g," ").split(" ").map(s=>s.charAt(0).toUpperCase()+s.slice(1)).join(" ");return h[c][o].map(s=>({...s,category:a}))}let r=null;try{r=await P(o,c)}catch(e){console.error("âŒ getSubcategories: Error getting category name:",e)}if(!r){console.warn(`âš ï¸ getSubcategories: Category not found for slug: ${o}, trying direct query...`);try{const{data:e,error:a}=await d.from("products_data").select("category").eq("manufacturer",c).not("category","is",null).neq("category","").limit(100);if(!a&&e){for(const s of e)if(s.category&&b(s.category)===o){r=s.category.trim(),console.log(`âœ… getSubcategories: Found category name via fallback: ${r}`);break}}}catch(e){console.error("âŒ getSubcategories: Fallback category lookup failed:",e)}if(!r)return console.error(`âŒ getSubcategories: Could not find category for slug: ${o}`),[]}console.log(`ðŸ“¦ getSubcategories: Using category name: ${r}`);try{console.log("ðŸ” getSubcategories: Trying RPC function...");const{data:e,error:a}=await d.rpc("get_subcategories_summary",{p_category_name:r,p_manufacturer_name:c});if(a)a.code==="42883"||a.message?.includes("function")||a.message?.includes("does not exist")?console.warn("âš ï¸ getSubcategories: RPC function does not exist, using fallback method"):console.warn("âš ï¸ getSubcategories: RPC function error:",a);else{if(e&&e.length>0)return console.log("âœ… getSubcategories: RPC function succeeded!",e.length,"subcategories"),e.map(s=>({name:s.subcategory_name,slug:b(s.subcategory_name),partCount:Number(s.part_count),category:r})).sort((s,n)=>s.name.localeCompare(n.name));console.warn("âš ï¸ getSubcategories: RPC function returned no data, using fallback")}}catch(e){console.warn("âš ï¸ getSubcategories: RPC function exception, using fallback method:",e)}const g=new Map,t=1e4;try{console.log(`ðŸ”„ getSubcategories: Using fallback method - sampling ${t} parts...`);const{data:e,error:a}=await d.from("products_data").select("sub_category").eq("category",r).eq("manufacturer",c).not("sub_category","is",null).neq("sub_category","").limit(t);if(a)return console.error("âŒ getSubcategories: Query error:",a),[];if(e&&e.length>0)console.log(`ðŸ“¦ getSubcategories: Fetched ${e.length} parts in sample`),e.forEach(s=>{if(s.sub_category&&s.sub_category.trim()!==""){const n=s.sub_category.trim();g.set(n,(g.get(n)||0)+1)}}),console.log(`âœ… getSubcategories: Found ${g.size} unique subcategories in sample`),e.length>=t&&console.warn("âš ï¸ getSubcategories: Sample size reached - using approximate counts");else return console.warn("âš ï¸ getSubcategories: No data returned from query"),[]}catch(e){return console.error("âŒ getSubcategories: Error in fallback method:",e),[]}return Array.from(g.entries()).map(([e,a])=>({name:e,slug:b(e),partCount:a,category:r})).sort((e,a)=>e.name.localeCompare(a.name))},$=(o,c,r)=>{if(r==="Amatom"&&C[r]){const g=C[r].find(a=>a.slug===o);if(!g)return{categoryName:null,subcategoryName:null};const t=h[r]?.[o];if(!t)return{categoryName:g.name,subcategoryName:null};const e=t.find(a=>a.slug===c);return e?{categoryName:g.name,subcategoryName:e.name}:{categoryName:g.name,subcategoryName:null}}return{categoryName:null,subcategoryName:null}},R=async(o,c,r,g=1,t=50)=>{console.log("ðŸ”„ getPartsBySubcategory: Starting query",{categorySlug:o,subcategorySlug:c,manufacturer:r,page:g,limit:t});const e=$(o,c,r);if(console.log("ðŸ” getPartsBySubcategory: Hardcoded names lookup:",e),e.categoryName&&e.subcategoryName){console.log("âœ… getPartsBySubcategory: Using HARDCODED names:",e);const y=(g-1)*t,N=y+t-1;console.log("ðŸ“Š getPartsBySubcategory: Query params:",{category:e.categoryName,subcategory:e.subcategoryName,manufacturer:r,from:y,to:N});try{const{data:f,count:_,error:p}=await d.from("products_data").select("*",{count:"exact"}).eq("category",e.categoryName).eq("sub_category",e.subcategoryName).eq("manufacturer",r).order("productname",{ascending:!0}).range(y,N);if(p)throw console.error("âŒ getPartsBySubcategory: Supabase error:",p),console.error("âŒ Query details:",{category:e.categoryName,subcategory:e.subcategoryName,manufacturer:r,errorCode:p.code,errorMessage:p.message}),p;return console.log(`âœ… getPartsBySubcategory: Success! Fetched ${f?.length||0} parts (page ${g}, total: ${_||0})`),f&&f.length>0&&console.log("ðŸ“¦ First part sample:",{id:f[0].id,productname:f[0].productname,category:f[0].category,sub_category:f[0].sub_category}),{parts:f||[],total:_||0}}catch(f){throw console.error("âŒ getPartsBySubcategory: Exception in hardcoded query:",f),f}}console.log("âš ï¸ getPartsBySubcategory: Using database lookup fallback...");const a=await P(o,r);if(!a)return console.warn("âŒ getPartsBySubcategory: Category not found for slug:",o),{parts:[],total:0};const{data:s,error:n}=await d.from("products_data").select("sub_category").eq("category",a).eq("manufacturer",r).not("sub_category","is",null).neq("sub_category","").limit(1e3);if(n)throw n;const l=new Set;s?.forEach(y=>{y.sub_category&&y.sub_category.trim()!==""&&l.add(y.sub_category.trim())});let u=null;for(const y of l)if(b(y)===c){u=y;break}if(!u)return console.warn("âŒ getPartsBySubcategory: Subcategory not found for slug:",c),{parts:[],total:0};const i=(g-1)*t,m=i+t-1,{data:S,count:q,error:w}=await d.from("products_data").select("*",{count:"exact"}).eq("category",a).eq("sub_category",u).eq("manufacturer",r).order("productname",{ascending:!0}).range(i,m);if(w)throw w;return{parts:S||[],total:q||0}},D=async(o,c)=>{let r=d.from("products_data").select("*").eq("productname",o);const{data:g,error:t}=await r.single();if(t){if(t.code==="PGRST116")return null;throw t}return g},F=async(o,c,r=50)=>{const{data:g,error:t}=await d.from("products_data").select("*").eq("manufacturer",c).or(`productname.ilike.%${o}%,description.ilike.%${o}%`).limit(r);if(t)throw t;return g||[]};export{D as a,A as b,k as c,R as g,F as s};
